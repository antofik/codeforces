
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="X-Csrf-Token" content="651cee51hhf4224aeh61c176dedc68ca"/>
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="-1">
    <meta name="google-site-verification" content="OTd2dN5x4nS4OPknPI9JFg36fKxjqY0i1PSfFPv_J90"/>
    <meta property="fb:admins" content="100001352546622" />
    <meta property="og:image" content="http://worker.codeforces.ru/static/images/codeforces-vk-square-ru.png"/>
    <meta property="og:title" content="Задачи - Codeforces"/>
    <meta property="og:site_name" content="Codeforces"/>
    
    <meta name="cc" content="10qg9p6vf1d9d"/>
    
    <meta name="verify-reformal" content="f56f99fd7e087fb6ccb48ef2" />
    <title>Задачи - Codeforces</title>
        <meta name="description" content="Codeforces. Соревнования и олимпиады по информатике и программированию, сообщество программистов" />
        <meta name="keywords" content="программирование информатика контест олимпиада алгоритмы c++ java графы vkcup" />
    <meta name="robots" content="index, follow" />

    <link href="http://worker.codeforces.ru/static/css/font-awesome.min.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Cuprum&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

    <HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--CombineResourcesFilter-->
    
<LINK href="http://worker.codeforces.ru/static/favicon.png" rel="shortcut icon" type="image/png">
    
<LINK href="http://worker.codeforces.ru/static/css/prettify.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/clear.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/style.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/ttypography.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/problem-statement.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/second-level-menu.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/roundbox.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/datatable.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/topic.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/table-form.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/jquery.jgrowl.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/facebox.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/jquery.wysiwyg.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/jquery.autocomplete.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/codeforces.datepick.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/colorbox.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/jquery.drafts.css" rel="stylesheet" type="text/css">
    
<LINK href="http://worker.codeforces.ru/static/markitup/skins/markitup/style.css" rel="stylesheet" type="text/css">
    
<LINK href="http://worker.codeforces.ru/static/markitup/sets/markdown/style.css" rel="stylesheet" type="text/css">

    
<SCRIPT charset="utf-8" src="//yandex.st/share/share.js" type="text/javascript"></SCRIPT>
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/sidebar-menu.css" rel="stylesheet" type="text/css">
    
<LINK charset="utf-8" href="http://worker.codeforces.ru/static/css/community.css" rel="stylesheet" type="text/css">

    <!--[if IE]>
        <style>
            #sidebar {
                padding-left: 1em;
                margin: 1em 1em 1em 0;
            }
        </style>
    <![endif]-->
    
    
<SCRIPT src="http://worker.codeforces.ru/static/js/prettify/prettify.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery-1.8.3.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/sockjs-0.2.1.min.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/vertxbus-1.2.min.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.easing.min.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.lavalamp.min.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.jgrowl.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/facebox.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.wysiwyg.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/controls/wysiwyg.colorpicker.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/controls/wysiwyg.table.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/controls/wysiwyg.image.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/controls/wysiwyg.link.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.autocomplete.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.datepick.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.ie6blocker.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.colorbox-min.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.ba-bbq.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/jquery.drafts.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/js/codeforces.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/markitup/jquery.markitup.js" type="text/javascript"></SCRIPT>
    <SCRIPT src="http://worker.codeforces.ru/static/markitup/sets/markdown/set.js" type="text/javascript"></SCRIPT>
    <!--/CombineResourcesFilter-->
</HEAD>
</HTML>

        <script type="text/javascript" src="http://worker.codeforces.ru/static/js/jquery.datepick-ru.js"></script>
        <script src="http://vk.com/js/api/openapi.js" type="text/javascript"></script>
</head>
<body><span style='display:none;' class='csrf-token' data-csrf='651cee51hhf4224aeh61c176dedc68ca'>&nbsp;</span>
<!-- Codeforces javascripts. -->
<script type="text/javascript">
    VK.init({apiId: 1961905});
</script>

<script type="text/javascript">
    if (window.parent.frames.length > 0) {
        window.stop();
    }
</script>

    <script type="text/javascript">
        $(document).ready(function() {
    $.ajaxPrefilter(function(options, originalOptions, xhr) {
        var csrf = Codeforces.getCsrfToken();

        if (csrf) {
            var data = originalOptions.data;
            if (originalOptions.data !== undefined) {
                if (Object.prototype.toString.call(originalOptions.data) === '[object String]') {
                    data = $.deparam(originalOptions.data);
                }
            } else {
                data = {};
            }
            options.data = $.param($.extend(data, { csrf_token: csrf }));
        }
    });

    window.updateTypography = function () {
        $("div.ttypography code").addClass("tt");
        $("div.ttypography pre>code").addClass("prettyprint").removeClass("tt");
        $("div.ttypography table").addClass("bordertable");
        prettyPrint();
    }

    $.ajaxSetup({ scriptCharset: "utf-8" ,contentType: "application/x-www-form-urlencoded; charset=UTF-8", headers: {
        'X-Csrf-Token': Codeforces.getCsrfToken()
    }});

    window.updateTypography();

    Codeforces.signForms();

    $(".second-level-menu-list").lavaLamp({
        fx: "backout",
        speed: 1000
    });


    Codeforces.countdown();
    $("a[rel='photobox']").colorbox();


        });
    </script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-743380-5']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<div id="body">
<div style="width: 950px; margin: 0 auto;">
    <div id="header" style="position:relative;">
        <div style="float:left;">
            <div style="padding:1em 0 0 2px;color:#C60C30;font-size:18px;font-weight:bold;">
<a href="/abbyycup20"><img src="http://www.abbyy.ru/images/logo.gif"/></a>
<span style="padding:1.5em;position:relative;bottom:7px;">Умный Бобер ждет вас на ABBYY Cup 2.0!</span>
</div>
        </div>
        <div class="lang">
            <div style="text-align: right;">
                <a href="?locale=en"><img src="http://worker.codeforces.ru/static/images/flags/24/gb.png" title="In English" alt="In English"/></a>
                <a href="?locale=ru"><img src="http://worker.codeforces.ru/static/images/flags/24/ru.png" title="По-русски" alt="По-русски"/></a>
            </div>
        </div>
        <br style="clear: both;"/>
    </div>

    <div style="text-align: center;font-size: 18px;margin-bottom: 0.5em;"
         class="caption">ABBYY Cup 2.0 - Hard</div>
    <div style="border-top: 1px solid #ccc; height: 1em;"></div>

        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">A1. Развивающая игра</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY начал разработку новой развивающей игры для детей. Правила игры достаточно просты и описаны ниже.</p><p>Игровое поле представляет собой последовательность из <span class="tex-span"><i>n</i></span> целых неотрицательных чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. Цель игры — сделать числа <span class="tex-span"><i>a</i><sub class="lower-index">1</sub>, <i>a</i><sub class="lower-index">2</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub></span> (то есть некоторый префикс последовательности) равными нулю для некоторого фиксированного <span class="tex-span"><i>k</i></span> <span class="tex-span">(<i>k</i> &lt; <i>n</i>)</span>, причем требуется сделать это за минимальное количество ходов.</p><p>Один ход заключается в выборе целого числа <span class="tex-span"><i>i</i></span> (<span class="tex-span">1 ≤ <i>i</i> ≤ <i>n</i></span>) такого, что <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub> &gt; 0</span>, и целого числа <span class="tex-span"><i>t</i></span> <span class="tex-span">(<i>t</i> ≥ 0)</span> такого, что <span class="tex-span"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup> ≤ <i>n</i></span>. После выбора чисел <span class="tex-span"><i>i</i></span> и <span class="tex-span"><i>t</i></span> значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> уменьшается на <span class="tex-span">1</span>, а значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup></sub></span> увеличивается на <span class="tex-span">1</span>. Например, пусть <span class="tex-span"><i>n</i> = 4</span> и <span class="tex-span"><i>a</i> = (1, 0, 1, 2)</span>, тогда можно сделать ход <span class="tex-span"><i>i</i> = 3</span>, <span class="tex-span"><i>t</i> = 0</span> и получить <span class="tex-span"><i>a</i> = (1, 0, 0, 3)</span> или сделать ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 1</span> и получить <span class="tex-span"><i>a</i> = (0, 0, 2, 2)</span> (возможен также ещё один ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 0</span>).</p><p>Вам дано целое число <span class="tex-span"><i>n</i></span> и изначальная последовательность <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется для всевозможных <span class="tex-span"><i>k</i></span> <span class="tex-span">(1 ≤ <i>k</i> &lt; <i>n</i>)</span> посчитать минимальное количество ходов, которое требуется сделать, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Вторая строка содержит <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">4</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 300</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>n</i> - 1</span> строку: <span class="tex-span"><i>k</i></span>-ая строка выходных данных должна содержать минимальное количество ходов, которое требуется для того, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>4<br />1 0 1 2<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />1<br />3<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>8<br />1 2 3 4 5 6 7 8<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />3<br />6<br />10<br />16<br />24<br />40<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">A2. Развивающая игра</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY начал разработку новой развивающей игры для детей. Правила игры достаточно просты и описаны ниже.</p><p>Игровое поле представляет собой последовательность из <span class="tex-span"><i>n</i></span> целых неотрицательных чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. Цель игры — сделать числа <span class="tex-span"><i>a</i><sub class="lower-index">1</sub>, <i>a</i><sub class="lower-index">2</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub></span> (то есть некоторый префикс последовательности) равными нулю для некоторого фиксированного <span class="tex-span"><i>k</i></span> <span class="tex-span">(<i>k</i> &lt; <i>n</i>)</span>, причем требуется сделать это за минимальное количество ходов.</p><p>Один ход заключается в выборе целого числа <span class="tex-span"><i>i</i></span> (<span class="tex-span">1 ≤ <i>i</i> ≤ <i>n</i></span>) такого, что <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub> &gt; 0</span>, и целого числа <span class="tex-span"><i>t</i></span> <span class="tex-span">(<i>t</i> ≥ 0)</span> такого, что <span class="tex-span"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup> ≤ <i>n</i></span>. После выбора чисел <span class="tex-span"><i>i</i></span> и <span class="tex-span"><i>t</i></span> значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> уменьшается на <span class="tex-span">1</span>, а значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup></sub></span> увеличивается на <span class="tex-span">1</span>. Например, пусть <span class="tex-span"><i>n</i> = 4</span> и <span class="tex-span"><i>a</i> = (1, 0, 1, 2)</span>, тогда можно сделать ход <span class="tex-span"><i>i</i> = 3</span>, <span class="tex-span"><i>t</i> = 0</span> и получить <span class="tex-span"><i>a</i> = (1, 0, 0, 3)</span> или сделать ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 1</span> и получить <span class="tex-span"><i>a</i> = (0, 0, 2, 2)</span> (возможен также ещё один ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 0</span>).</p><p>Вам дано целое число <span class="tex-span"><i>n</i></span> и изначальная последовательность <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется для всевозможных <span class="tex-span"><i>k</i></span> <span class="tex-span">(1 ≤ <i>k</i> &lt; <i>n</i>)</span> посчитать минимальное количество ходов, которое требуется сделать, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Вторая строка содержит <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">4</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 300</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>n</i> - 1</span> строку: <span class="tex-span"><i>k</i></span>-ая строка выходных данных должна содержать минимальное количество ходов, которое требуется для того, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>4<br />1 0 1 2<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />1<br />3<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>8<br />1 2 3 4 5 6 7 8<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />3<br />6<br />10<br />16<br />24<br />40<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">A3. Развивающая игра</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY начал разработку новой развивающей игры для детей. Правила игры достаточно просты и описаны ниже.</p><p>Игровое поле представляет собой последовательность из <span class="tex-span"><i>n</i></span> целых неотрицательных чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. Цель игры — сделать числа <span class="tex-span"><i>a</i><sub class="lower-index">1</sub>, <i>a</i><sub class="lower-index">2</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub></span> (то есть некоторый префикс последовательности) равными нулю для некоторого фиксированного <span class="tex-span"><i>k</i></span> <span class="tex-span">(<i>k</i> &lt; <i>n</i>)</span>, причем требуется сделать это за минимальное количество ходов.</p><p>Один ход заключается в выборе целого числа <span class="tex-span"><i>i</i></span> (<span class="tex-span">1 ≤ <i>i</i> ≤ <i>n</i></span>) такого, что <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub> &gt; 0</span>, и целого числа <span class="tex-span"><i>t</i></span> <span class="tex-span">(<i>t</i> ≥ 0)</span> такого, что <span class="tex-span"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup> ≤ <i>n</i></span>. После выбора чисел <span class="tex-span"><i>i</i></span> и <span class="tex-span"><i>t</i></span> значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> уменьшается на <span class="tex-span">1</span>, а значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i> + 2<sup class="upper-index"><i>t</i></sup></sub></span> увеличивается на <span class="tex-span">1</span>. Например, пусть <span class="tex-span"><i>n</i> = 4</span> и <span class="tex-span"><i>a</i> = (1, 0, 1, 2)</span>, тогда можно сделать ход <span class="tex-span"><i>i</i> = 3</span>, <span class="tex-span"><i>t</i> = 0</span> и получить <span class="tex-span"><i>a</i> = (1, 0, 0, 3)</span> или сделать ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 1</span> и получить <span class="tex-span"><i>a</i> = (0, 0, 2, 2)</span> (возможен также ещё один ход <span class="tex-span"><i>i</i> = 1</span>, <span class="tex-span"><i>t</i> = 0</span>).</p><p>Вам дано целое число <span class="tex-span"><i>n</i></span> и изначальная последовательность <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется для всевозможных <span class="tex-span"><i>k</i></span> <span class="tex-span">(1 ≤ <i>k</i> &lt; <i>n</i>)</span> посчитать минимальное количество ходов, которое требуется сделать, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Вторая строка содержит <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">4</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 300</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>n</i> - 1</span> строку: <span class="tex-span"><i>k</i></span>-ая строка выходных данных должна содержать минимальное количество ходов, которое требуется для того, чтобы обнулить первые <span class="tex-span"><i>k</i></span> элементов изначальной последовательности <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>4<br />1 0 1 2<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />1<br />3<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>8<br />1 2 3 4 5 6 7 8<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>1<br />3<br />6<br />10<br />16<br />24<br />40<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">B1. Жадные торговцы</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>В ABBYY живет замечательный Умный Бобер. На этот раз он занялся изучением истории. Когда он читал про Римскую империю, его заинтересовала жизнь торговцев. </p><p>Римская империя состояла из <span class="tex-span"><i>n</i></span> городов, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. В ней также существовало <span class="tex-span"><i>m</i></span> двунаправленныx дорог, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>m</i></span>. Каждая дорога связывала между собой два различных города. Любые два города были соединены не более чем одной дорогой.</p><p>Будем говорить, что между городами <span class="tex-span"><i>c</i><sub class="lower-index">1</sub></span> и <span class="tex-span"><i>c</i><sub class="lower-index">2</sub></span> существует путь, если существует конечная последовательность городов <span class="tex-span"><i>t</i><sub class="lower-index">1</sub>, <i>t</i><sub class="lower-index">2</sub>, ..., <i>t</i><sub class="lower-index"><i>p</i></sub></span> <span class="tex-span">(<i>p</i> ≥ 1)</span> такая, что:</p><p><ul> <li> <span class="tex-span"><i>t</i><sub class="lower-index">1</sub> = <i>c</i><sub class="lower-index">1</sub></span> </li><li> <span class="tex-span"><i>t</i><sub class="lower-index"><i>p</i></sub> = <i>c</i><sub class="lower-index">2</sub></span> </li><li> для любого <span class="tex-span"><i>i</i></span> <span class="tex-span">(1 ≤ <i>i</i> &lt; <i>p</i>)</span> города <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i> + 1</sub></span> связаны дорогой </li></ul> </p><p>Известно, что в Римской империи между любыми двумя городами существовал путь.</p><p>В империи жили <span class="tex-span"><i>k</i></span> торговцев, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>k</i></span>. Для каждого из них известна пара чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span>, где <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположен склад данного торговца, а <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена его торговая лавка. Лавка и склад могли находиться в разных городах, поэтому торговцам приходилось доставлять товар со склада до торговой лавки.</p><p>Назовем дорогу <span class="tex-font-style-it">важной</span> для торговца, если ее разрушение грозит торговцу разорением, то есть если без этой дороги не существует пути от его склада до его лавки. Торговцы в Римской империи очень жадные, поэтому каждый торговец платит налог (1 динарий) только за важные для него дороги. Другими словами, каждый торговец платит налог <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> динариев, где <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub> ≥ 0</span>) — количество важных для данного торговца дорог.</p><p>В империи настал день сбора налогов. Умный Бобер из ABBYY по природе своей очень любопытен, поэтому он решил посчитать, сколько динариев заплатил каждый торговец. И в этом ему нужна Ваша помощь.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>В первой строке входных данных записано два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>m</i></span>, разделенных пробелом. Число <span class="tex-span"><i>n</i></span> — это количество городов, а <span class="tex-span"><i>m</i></span> — количество дорог в империи. </p><p>Следующие <span class="tex-span"><i>m</i></span> строк содержат пары целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>b</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub>, <i>b</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>, <i>a</i><sub class="lower-index"><i>i</i></sub> ≠ <i>b</i><sub class="lower-index"><i>i</i></sub>)</span>, разделенных пробелом, — номера городов, соединенных <span class="tex-span"><i>i</i></span>-ой дорогой. Гарантируется, что любые два города соединены не более чем одной дорогой и что в Римской империи между любыми двумя городами существует путь.</p><p>Следующая строка содержит целое число <span class="tex-span"><i>k</i></span> — количество торговцев в империи.</p><p>Следующие <span class="tex-span"><i>k</i></span> строк содержат пары целых чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>s</i><sub class="lower-index"><i>i</i></sub>, <i>l</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>)</span>, разделенных пробелом, — число <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> обозначает номер города, в котором расположен склад <span class="tex-span"><i>i</i></span>-го торговца, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена лавка <span class="tex-span"><i>i</i></span>-го торговца. </p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 200</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>k</i></span> строк, в <span class="tex-span"><i>i</i></span>-ой из которых будет записано целое число <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> — число динариев, которое заплатил торговец с номером <span class="tex-span"><i>i</i></span>. </p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>7 8<br />1 2<br />2 3<br />3 4<br />4 5<br />5 6<br />5 7<br />3 5<br />4 7<br />4<br />1 5<br />2 4<br />2 6<br />4 7<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br />1<br />2<br />0<br /></pre></div></div></div><div class="note"><div class="section-title">Примечание</div><p>Данный пример проиллюстрирован на рисунке. <center> <img class="tex-graphics" src="http://codeforces.ru/renderer/e9fabfb9f33327f73006a2144fb56c801a98febe.png" /> </center></p><p>Распишем результат для первого торговца. Склад торговца находится в городе <span class="tex-span">1</span>, а лавка в городе <span class="tex-span">5</span>. Заметим, что при разрушении любой из дорог <span class="tex-span">(1, 2)</span> или <span class="tex-span">(2, 3)</span> путь между городами <span class="tex-span">1</span> и <span class="tex-span">5</span> пропадает. При разрушении любой другой дороги путь сохранится. Поэтому для данного торговца ответ <span class="tex-span">2</span>.</p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">B2. Жадные торговцы</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>В ABBYY живет замечательный Умный Бобер. На этот раз он занялся изучением истории. Когда он читал про Римскую империю, его заинтересовала жизнь торговцев. </p><p>Римская империя состояла из <span class="tex-span"><i>n</i></span> городов, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. В ней также существовало <span class="tex-span"><i>m</i></span> двунаправленныx дорог, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>m</i></span>. Каждая дорога связывала между собой два различных города. Любые два города были соединены не более чем одной дорогой.</p><p>Будем говорить, что между городами <span class="tex-span"><i>c</i><sub class="lower-index">1</sub></span> и <span class="tex-span"><i>c</i><sub class="lower-index">2</sub></span> существует путь, если существует конечная последовательность городов <span class="tex-span"><i>t</i><sub class="lower-index">1</sub>, <i>t</i><sub class="lower-index">2</sub>, ..., <i>t</i><sub class="lower-index"><i>p</i></sub></span> <span class="tex-span">(<i>p</i> ≥ 1)</span> такая, что:</p><p><ul> <li> <span class="tex-span"><i>t</i><sub class="lower-index">1</sub> = <i>c</i><sub class="lower-index">1</sub></span> </li><li> <span class="tex-span"><i>t</i><sub class="lower-index"><i>p</i></sub> = <i>c</i><sub class="lower-index">2</sub></span> </li><li> для любого <span class="tex-span"><i>i</i></span> <span class="tex-span">(1 ≤ <i>i</i> &lt; <i>p</i>)</span> города <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i> + 1</sub></span> связаны дорогой </li></ul> </p><p>Известно, что в Римской империи между любыми двумя городами существовал путь.</p><p>В империи жили <span class="tex-span"><i>k</i></span> торговцев, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>k</i></span>. Для каждого из них известна пара чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span>, где <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположен склад данного торговца, а <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена его торговая лавка. Лавка и склад могли находиться в разных городах, поэтому торговцам приходилось доставлять товар со склада до торговой лавки.</p><p>Назовем дорогу <span class="tex-font-style-it">важной</span> для торговца, если ее разрушение грозит торговцу разорением, то есть если без этой дороги не существует пути от его склада до его лавки. Торговцы в Римской империи очень жадные, поэтому каждый торговец платит налог (1 динарий) только за важные для него дороги. Другими словами, каждый торговец платит налог <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> динариев, где <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub> ≥ 0</span>) — количество важных для данного торговца дорог.</p><p>В империи настал день сбора налогов. Умный Бобер из ABBYY по природе своей очень любопытен, поэтому он решил посчитать, сколько динариев заплатил каждый торговец. И в этом ему нужна Ваша помощь.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>В первой строке входных данных записано два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>m</i></span>, разделенных пробелом. Число <span class="tex-span"><i>n</i></span> — это количество городов, а <span class="tex-span"><i>m</i></span> — количество дорог в империи. </p><p>Следующие <span class="tex-span"><i>m</i></span> строк содержат пары целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>b</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub>, <i>b</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>, <i>a</i><sub class="lower-index"><i>i</i></sub> ≠ <i>b</i><sub class="lower-index"><i>i</i></sub>)</span>, разделенных пробелом, — номера городов, соединенных <span class="tex-span"><i>i</i></span>-ой дорогой. Гарантируется, что любые два города соединены не более чем одной дорогой и что в Римской империи между любыми двумя городами существует путь.</p><p>Следующая строка содержит целое число <span class="tex-span"><i>k</i></span> — количество торговцев в империи.</p><p>Следующие <span class="tex-span"><i>k</i></span> строк содержат пары целых чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>s</i><sub class="lower-index"><i>i</i></sub>, <i>l</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>)</span>, разделенных пробелом, — число <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> обозначает номер города, в котором расположен склад <span class="tex-span"><i>i</i></span>-го торговца, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена лавка <span class="tex-span"><i>i</i></span>-го торговца. </p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 200</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>k</i></span> строк, в <span class="tex-span"><i>i</i></span>-ой из которых будет записано целое число <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> — число динариев, которое заплатил торговец с номером <span class="tex-span"><i>i</i></span>. </p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>7 8<br />1 2<br />2 3<br />3 4<br />4 5<br />5 6<br />5 7<br />3 5<br />4 7<br />4<br />1 5<br />2 4<br />2 6<br />4 7<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br />1<br />2<br />0<br /></pre></div></div></div><div class="note"><div class="section-title">Примечание</div><p>Данный пример проиллюстрирован на рисунке. <center> <img class="tex-graphics" src="http://codeforces.ru/renderer/e9fabfb9f33327f73006a2144fb56c801a98febe.png" /> </center></p><p>Распишем результат для первого торговца. Склад торговца находится в городе <span class="tex-span">1</span>, а лавка в городе <span class="tex-span">5</span>. Заметим, что при разрушении любой из дорог <span class="tex-span">(1, 2)</span> или <span class="tex-span">(2, 3)</span> путь между городами <span class="tex-span">1</span> и <span class="tex-span">5</span> пропадает. При разрушении любой другой дороги путь сохранится. Поэтому для данного торговца ответ <span class="tex-span">2</span>.</p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">B3. Жадные торговцы</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>В ABBYY живет замечательный Умный Бобер. На этот раз он занялся изучением истории. Когда он читал про Римскую империю, его заинтересовала жизнь торговцев. </p><p>Римская империя состояла из <span class="tex-span"><i>n</i></span> городов, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. В ней также существовало <span class="tex-span"><i>m</i></span> двунаправленныx дорог, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>m</i></span>. Каждая дорога связывала между собой два различных города. Любые два города были соединены не более чем одной дорогой.</p><p>Будем говорить, что между городами <span class="tex-span"><i>c</i><sub class="lower-index">1</sub></span> и <span class="tex-span"><i>c</i><sub class="lower-index">2</sub></span> существует путь, если существует конечная последовательность городов <span class="tex-span"><i>t</i><sub class="lower-index">1</sub>, <i>t</i><sub class="lower-index">2</sub>, ..., <i>t</i><sub class="lower-index"><i>p</i></sub></span> <span class="tex-span">(<i>p</i> ≥ 1)</span> такая, что:</p><p><ul> <li> <span class="tex-span"><i>t</i><sub class="lower-index">1</sub> = <i>c</i><sub class="lower-index">1</sub></span> </li><li> <span class="tex-span"><i>t</i><sub class="lower-index"><i>p</i></sub> = <i>c</i><sub class="lower-index">2</sub></span> </li><li> для любого <span class="tex-span"><i>i</i></span> <span class="tex-span">(1 ≤ <i>i</i> &lt; <i>p</i>)</span> города <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>t</i><sub class="lower-index"><i>i</i> + 1</sub></span> связаны дорогой </li></ul> </p><p>Известно, что в Римской империи между любыми двумя городами существовал путь.</p><p>В империи жили <span class="tex-span"><i>k</i></span> торговцев, пронумерованных от <span class="tex-span">1</span> до <span class="tex-span"><i>k</i></span>. Для каждого из них известна пара чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> и <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span>, где <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположен склад данного торговца, а <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена его торговая лавка. Лавка и склад могли находиться в разных городах, поэтому торговцам приходилось доставлять товар со склада до торговой лавки.</p><p>Назовем дорогу <span class="tex-font-style-it">важной</span> для торговца, если ее разрушение грозит торговцу разорением, то есть если без этой дороги не существует пути от его склада до его лавки. Торговцы в Римской империи очень жадные, поэтому каждый торговец платит налог (1 динарий) только за важные для него дороги. Другими словами, каждый торговец платит налог <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> динариев, где <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub> ≥ 0</span>) — количество важных для данного торговца дорог.</p><p>В империи настал день сбора налогов. Умный Бобер из ABBYY по природе своей очень любопытен, поэтому он решил посчитать, сколько динариев заплатил каждый торговец. И в этом ему нужна Ваша помощь.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>В первой строке входных данных записано два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>m</i></span>, разделенных пробелом. Число <span class="tex-span"><i>n</i></span> — это количество городов, а <span class="tex-span"><i>m</i></span> — количество дорог в империи. </p><p>Следующие <span class="tex-span"><i>m</i></span> строк содержат пары целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>b</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>a</i><sub class="lower-index"><i>i</i></sub>, <i>b</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>, <i>a</i><sub class="lower-index"><i>i</i></sub> ≠ <i>b</i><sub class="lower-index"><i>i</i></sub>)</span>, разделенных пробелом, — номера городов, соединенных <span class="tex-span"><i>i</i></span>-ой дорогой. Гарантируется, что любые два города соединены не более чем одной дорогой и что в Римской империи между любыми двумя городами существует путь.</p><p>Следующая строка содержит целое число <span class="tex-span"><i>k</i></span> — количество торговцев в империи.</p><p>Следующие <span class="tex-span"><i>k</i></span> строк содержат пары целых чисел <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span>, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> <span class="tex-span">(1 ≤ <i>s</i><sub class="lower-index"><i>i</i></sub>, <i>l</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>)</span>, разделенных пробелом, — число <span class="tex-span"><i>s</i><sub class="lower-index"><i>i</i></sub></span> обозначает номер города, в котором расположен склад <span class="tex-span"><i>i</i></span>-го торговца, <span class="tex-span"><i>l</i><sub class="lower-index"><i>i</i></sub></span> — номер города, в котором расположена лавка <span class="tex-span"><i>i</i></span>-го торговца. </p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 200</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 200</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 2000</span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 2000</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>m</i> ≤ 10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>k</i> ≤ 10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно <span class="tex-span"><i>k</i></span> строк, в <span class="tex-span"><i>i</i></span>-ой из которых будет записано целое число <span class="tex-span"><i>d</i><sub class="lower-index"><i>i</i></sub></span> — число динариев, которое заплатил торговец с номером <span class="tex-span"><i>i</i></span>. </p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>7 8<br />1 2<br />2 3<br />3 4<br />4 5<br />5 6<br />5 7<br />3 5<br />4 7<br />4<br />1 5<br />2 4<br />2 6<br />4 7<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br />1<br />2<br />0<br /></pre></div></div></div><div class="note"><div class="section-title">Примечание</div><p>Данный пример проиллюстрирован на рисунке. <center> <img class="tex-graphics" src="http://codeforces.ru/renderer/e9fabfb9f33327f73006a2144fb56c801a98febe.png" /> </center></p><p>Распишем результат для первого торговца. Склад торговца находится в городе <span class="tex-span">1</span>, а лавка в городе <span class="tex-span">5</span>. Заметим, что при разрушении любой из дорог <span class="tex-span">(1, 2)</span> или <span class="tex-span">(2, 3)</span> путь между городами <span class="tex-span">1</span> и <span class="tex-span">5</span> пропадает. При разрушении любой другой дороги путь сохранится. Поэтому для данного торговца ответ <span class="tex-span">2</span>.</p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">C1. Бобер и разрешение коллизий</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY имеет множество увлечений. Одно из них — это построение эффективных хеш-таблиц. Одной из самых серьезных проблем в хеш-таблицах является разрешение коллизий. Бобра очень заинтересовала эта проблема и он решил подробно ее исследовать.</p><p>Будем считать, что хеш-таблица состоит из <span class="tex-span"><i>h</i></span> ячеек, пронумерованных от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>. В нее добавляются и из нее удаляются объекты. Каждый объект имеет свой уникальный идентификатор. Кроме этого, каждому объекту соответствует некоторое значение хеш-функции — целое число из отрезка от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>, включительно. Если при добавлении объекта ячейка, соответствующая значению хеш-функции объекта, свободна, то в нее помещается данный объект. В случае же, когда ячейка уже занята другим объектом, возникает коллизия. При удалении объекта из таблицы ячейка, в которую он был помещен, освобождается.</p><p>Умный Бобер недавно узнал о методе линейного пробирования для разрешения коллизий. Он заключается в следующем. Пусть значение хеш-функции для добавляемого объекта равно <span class="tex-span"><i>t</i></span> и ячейка таблицы с номером <span class="tex-span"><i>t</i></span> уже занята. Тогда мы пытаемся добавить этот элемент в ячейку <span class="tex-span">(<i>t</i> + <i>m</i>) <i>mod</i> <i>h</i></span>. Если и она занята, то в ячейку <span class="tex-span">(<i>t</i> + 2·<i>m</i>) <i>mod</i> <i>h</i></span>, затем в ячейку <span class="tex-span">(<i>t</i> + 3·<i>m</i>) <i>mod</i> <i>h</i></span> и так далее. Заметим, что возможны ситуации, когда новый объект невозможно добавить в таблицу. <span class="tex-font-style-it">Во входных данных для этой задачи гарантируется отсутствие таких ситуаций</span>.</p><p>Операция <span class="tex-span"><i>a</i> <i>mod</i> <i>b</i></span> обозначает взятие остатка от деления числа <span class="tex-span"><i>a</i></span> на число <span class="tex-span"><i>b</i></span>.</p><p>Данная методика сразу же показалась Бобру весьма неоптимальной и он решил оценить её неэффективность. Итак, вам дана последовательность операций добавления и удаления объектов из таблицы. При добавлении нового объекта происходит последовательность обращений к таблице. Каждое обращение к занятой ячейке таблицы будем называть холостым. Другими словами, если в результате алгоритма, описанного выше, объект добавился в ячейку <span class="tex-span">(<i>t</i> + <i>i</i>·<i>m</i>) <i>mod</i> <i>h</i></span> <span class="tex-span">(<i>i</i> ≥ 0)</span>, то произошло ровно <span class="tex-span"><i>i</i></span> холостых обращений. </p><p>Требуется для данной последовательности операций добавления в таблицу и удаления из нее посчитать общее число холостых обращений к таблице. Будем считать, что при удалении некоторого объекта из таблицы не происходит холостых обращений. Также будем считать, что таблица перед выполнением операций пуста, то есть в ней нет ни одного объекта.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит три целых числа <span class="tex-span"><i>h</i></span>, <span class="tex-span"><i>m</i></span> и <span class="tex-span"><i>n</i></span> (<span class="tex-span">1 ≤ <i>m</i> &lt; <i>h</i></span>), разделенных пробелами, где <span class="tex-span"><i>h</i></span> — размер хеш-таблицы, <span class="tex-span"><i>m</i></span> — число, используемое для разрешения коллизий, <span class="tex-span"><i>n</i></span> — количество операций. </p><p>В следующих <span class="tex-span"><i>n</i></span> строках содержится описание операций. Порядок их выполнения соответствует порядку, в котором они следуют во входном файле. Каждая операция описывается одной строкой. Формат описания операций следующий:</p><p><ul> <li> «<span class="tex-font-style-tt">+ id hash</span>»</li></ul></p><p>Такой формат имеет операция добавления объекта в таблицу. Первый символ «<span class="tex-font-style-tt">+</span>» (ASCII 43), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>, затем еще один пробел и значение хеш-функции для данного объекта <span class="tex-span"><i>hash</i></span> <span class="tex-span">(0 ≤ <i>hash</i> &lt; <i>h</i>)</span>. Идентификатор объекта и значение хеш-функции для данного объекта являются целыми числами.</p><p><li> «<span class="tex-font-style-tt">- id</span>»</li></p><p>Такой формат имеет операция удаления объекта из таблицы. Первый символ «<span class="tex-font-style-tt">-</span>» (ASCII 45), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>. Идентификатор объекта — целое число.</p><p>Гарантируется, что для всех операций добавления значение идентификатора является уникальным. Также гарантируется корректность исходных данных, то есть объект всегда возможно будет добавить в хеш-таблицу и не будет удалений несуществующих объектов.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5000</span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5000</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — суммарное количество холостых обращений к хеш-таблице.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>10 2 7<br />+ 11 0<br />+ 22 2<br />+ 33 6<br />+ 44 0<br />+ 55 0<br />- 22<br />+ 66 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>7<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>5 1 6<br />+ 123 0<br />+ 234 1<br />+ 345 2<br />- 234<br />+ 456 0<br />+ 567 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>4<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">C2. Бобер и разрешение коллизий</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY имеет множество увлечений. Одно из них — это построение эффективных хеш-таблиц. Одной из самых серьезных проблем в хеш-таблицах является разрешение коллизий. Бобра очень заинтересовала эта проблема и он решил подробно ее исследовать.</p><p>Будем считать, что хеш-таблица состоит из <span class="tex-span"><i>h</i></span> ячеек, пронумерованных от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>. В нее добавляются и из нее удаляются объекты. Каждый объект имеет свой уникальный идентификатор. Кроме этого, каждому объекту соответствует некоторое значение хеш-функции — целое число из отрезка от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>, включительно. Если при добавлении объекта ячейка, соответствующая значению хеш-функции объекта, свободна, то в нее помещается данный объект. В случае же, когда ячейка уже занята другим объектом, возникает коллизия. При удалении объекта из таблицы ячейка, в которую он был помещен, освобождается.</p><p>Умный Бобер недавно узнал о методе линейного пробирования для разрешения коллизий. Он заключается в следующем. Пусть значение хеш-функции для добавляемого объекта равно <span class="tex-span"><i>t</i></span> и ячейка таблицы с номером <span class="tex-span"><i>t</i></span> уже занята. Тогда мы пытаемся добавить этот элемент в ячейку <span class="tex-span">(<i>t</i> + <i>m</i>) <i>mod</i> <i>h</i></span>. Если и она занята, то в ячейку <span class="tex-span">(<i>t</i> + 2·<i>m</i>) <i>mod</i> <i>h</i></span>, затем в ячейку <span class="tex-span">(<i>t</i> + 3·<i>m</i>) <i>mod</i> <i>h</i></span> и так далее. Заметим, что возможны ситуации, когда новый объект невозможно добавить в таблицу. <span class="tex-font-style-it">Во входных данных для этой задачи гарантируется отсутствие таких ситуаций</span>.</p><p>Операция <span class="tex-span"><i>a</i> <i>mod</i> <i>b</i></span> обозначает взятие остатка от деления числа <span class="tex-span"><i>a</i></span> на число <span class="tex-span"><i>b</i></span>.</p><p>Данная методика сразу же показалась Бобру весьма неоптимальной и он решил оценить её неэффективность. Итак, вам дана последовательность операций добавления и удаления объектов из таблицы. При добавлении нового объекта происходит последовательность обращений к таблице. Каждое обращение к занятой ячейке таблицы будем называть холостым. Другими словами, если в результате алгоритма, описанного выше, объект добавился в ячейку <span class="tex-span">(<i>t</i> + <i>i</i>·<i>m</i>) <i>mod</i> <i>h</i></span> <span class="tex-span">(<i>i</i> ≥ 0)</span>, то произошло ровно <span class="tex-span"><i>i</i></span> холостых обращений. </p><p>Требуется для данной последовательности операций добавления в таблицу и удаления из нее посчитать общее число холостых обращений к таблице. Будем считать, что при удалении некоторого объекта из таблицы не происходит холостых обращений. Также будем считать, что таблица перед выполнением операций пуста, то есть в ней нет ни одного объекта.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит три целых числа <span class="tex-span"><i>h</i></span>, <span class="tex-span"><i>m</i></span> и <span class="tex-span"><i>n</i></span> (<span class="tex-span">1 ≤ <i>m</i> &lt; <i>h</i></span>), разделенных пробелами, где <span class="tex-span"><i>h</i></span> — размер хеш-таблицы, <span class="tex-span"><i>m</i></span> — число, используемое для разрешения коллизий, <span class="tex-span"><i>n</i></span> — количество операций. </p><p>В следующих <span class="tex-span"><i>n</i></span> строках содержится описание операций. Порядок их выполнения соответствует порядку, в котором они следуют во входном файле. Каждая операция описывается одной строкой. Формат описания операций следующий:</p><p><ul> <li> «<span class="tex-font-style-tt">+ id hash</span>»</li></ul></p><p>Такой формат имеет операция добавления объекта в таблицу. Первый символ «<span class="tex-font-style-tt">+</span>» (ASCII 43), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>, затем еще один пробел и значение хеш-функции для данного объекта <span class="tex-span"><i>hash</i></span> <span class="tex-span">(0 ≤ <i>hash</i> &lt; <i>h</i>)</span>. Идентификатор объекта и значение хеш-функции для данного объекта являются целыми числами.</p><p><li> «<span class="tex-font-style-tt">- id</span>»</li></p><p>Такой формат имеет операция удаления объекта из таблицы. Первый символ «<span class="tex-font-style-tt">-</span>» (ASCII 45), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>. Идентификатор объекта — целое число.</p><p>Гарантируется, что для всех операций добавления значение идентификатора является уникальным. Также гарантируется корректность исходных данных, то есть объект всегда возможно будет добавить в хеш-таблицу и не будет удалений несуществующих объектов.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5000</span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5000</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — суммарное количество холостых обращений к хеш-таблице.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>10 2 7<br />+ 11 0<br />+ 22 2<br />+ 33 6<br />+ 44 0<br />+ 55 0<br />- 22<br />+ 66 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>7<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>5 1 6<br />+ 123 0<br />+ 234 1<br />+ 345 2<br />- 234<br />+ 456 0<br />+ 567 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>4<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">C3. Бобер и разрешение коллизий</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY имеет множество увлечений. Одно из них — это построение эффективных хеш-таблиц. Одной из самых серьезных проблем в хеш-таблицах является разрешение коллизий. Бобра очень заинтересовала эта проблема и он решил подробно ее исследовать.</p><p>Будем считать, что хеш-таблица состоит из <span class="tex-span"><i>h</i></span> ячеек, пронумерованных от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>. В нее добавляются и из нее удаляются объекты. Каждый объект имеет свой уникальный идентификатор. Кроме этого, каждому объекту соответствует некоторое значение хеш-функции — целое число из отрезка от <span class="tex-span">0</span> до <span class="tex-span"><i>h</i> - 1</span>, включительно. Если при добавлении объекта ячейка, соответствующая значению хеш-функции объекта, свободна, то в нее помещается данный объект. В случае же, когда ячейка уже занята другим объектом, возникает коллизия. При удалении объекта из таблицы ячейка, в которую он был помещен, освобождается.</p><p>Умный Бобер недавно узнал о методе линейного пробирования для разрешения коллизий. Он заключается в следующем. Пусть значение хеш-функции для добавляемого объекта равно <span class="tex-span"><i>t</i></span> и ячейка таблицы с номером <span class="tex-span"><i>t</i></span> уже занята. Тогда мы пытаемся добавить этот элемент в ячейку <span class="tex-span">(<i>t</i> + <i>m</i>) <i>mod</i> <i>h</i></span>. Если и она занята, то в ячейку <span class="tex-span">(<i>t</i> + 2·<i>m</i>) <i>mod</i> <i>h</i></span>, затем в ячейку <span class="tex-span">(<i>t</i> + 3·<i>m</i>) <i>mod</i> <i>h</i></span> и так далее. Заметим, что возможны ситуации, когда новый объект невозможно добавить в таблицу. <span class="tex-font-style-it">Во входных данных для этой задачи гарантируется отсутствие таких ситуаций</span>.</p><p>Операция <span class="tex-span"><i>a</i> <i>mod</i> <i>b</i></span> обозначает взятие остатка от деления числа <span class="tex-span"><i>a</i></span> на число <span class="tex-span"><i>b</i></span>.</p><p>Данная методика сразу же показалась Бобру весьма неоптимальной и он решил оценить её неэффективность. Итак, вам дана последовательность операций добавления и удаления объектов из таблицы. При добавлении нового объекта происходит последовательность обращений к таблице. Каждое обращение к занятой ячейке таблицы будем называть холостым. Другими словами, если в результате алгоритма, описанного выше, объект добавился в ячейку <span class="tex-span">(<i>t</i> + <i>i</i>·<i>m</i>) <i>mod</i> <i>h</i></span> <span class="tex-span">(<i>i</i> ≥ 0)</span>, то произошло ровно <span class="tex-span"><i>i</i></span> холостых обращений. </p><p>Требуется для данной последовательности операций добавления в таблицу и удаления из нее посчитать общее число холостых обращений к таблице. Будем считать, что при удалении некоторого объекта из таблицы не происходит холостых обращений. Также будем считать, что таблица перед выполнением операций пуста, то есть в ней нет ни одного объекта.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит три целых числа <span class="tex-span"><i>h</i></span>, <span class="tex-span"><i>m</i></span> и <span class="tex-span"><i>n</i></span> (<span class="tex-span">1 ≤ <i>m</i> &lt; <i>h</i></span>), разделенных пробелами, где <span class="tex-span"><i>h</i></span> — размер хеш-таблицы, <span class="tex-span"><i>m</i></span> — число, используемое для разрешения коллизий, <span class="tex-span"><i>n</i></span> — количество операций. </p><p>В следующих <span class="tex-span"><i>n</i></span> строках содержится описание операций. Порядок их выполнения соответствует порядку, в котором они следуют во входном файле. Каждая операция описывается одной строкой. Формат описания операций следующий:</p><p><ul> <li> «<span class="tex-font-style-tt">+ id hash</span>»</li></ul></p><p>Такой формат имеет операция добавления объекта в таблицу. Первый символ «<span class="tex-font-style-tt">+</span>» (ASCII 43), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>, затем еще один пробел и значение хеш-функции для данного объекта <span class="tex-span"><i>hash</i></span> <span class="tex-span">(0 ≤ <i>hash</i> &lt; <i>h</i>)</span>. Идентификатор объекта и значение хеш-функции для данного объекта являются целыми числами.</p><p><li> «<span class="tex-font-style-tt">- id</span>»</li></p><p>Такой формат имеет операция удаления объекта из таблицы. Первый символ «<span class="tex-font-style-tt">-</span>» (ASCII 45), затем следует единичный пробел, затем идентификатор объекта <span class="tex-span"><i>id</i></span> <span class="tex-span">(0 ≤ <i>id</i> ≤ 10<sup class="upper-index">9</sup>)</span>. Идентификатор объекта — целое число.</p><p>Гарантируется, что для всех операций добавления значение идентификатора является уникальным. Также гарантируется корректность исходных данных, то есть объект всегда возможно будет добавить в хеш-таблицу и не будет удалений несуществующих объектов.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5000</span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5000</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 5·10<sup class="upper-index">4</sup></span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>h</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li><li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2·10<sup class="upper-index">5</sup></span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — суммарное количество холостых обращений к хеш-таблице.</p><p>Пожалуйста, не используйте спецификатор <span class="tex-font-style-tt">%lld</span> для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки <span class="tex-font-style-tt">cin</span>, <span class="tex-font-style-tt">cout</span>, а также спецификатор <span class="tex-font-style-tt">%I64d</span>.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>10 2 7<br />+ 11 0<br />+ 22 2<br />+ 33 6<br />+ 44 0<br />+ 55 0<br />- 22<br />+ 66 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>7<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>5 1 6<br />+ 123 0<br />+ 234 1<br />+ 345 2<br />- 234<br />+ 456 0<br />+ 567 0<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>4<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">D1. Магические квадраты</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY очень любит различные головоломки. Одной из самых его любимых головоломок являются магические квадраты. Совсем недавно ему пришла в голову идея по автоматизации решения данной головоломки. Бобер решил обратиться с этой задачей к участникам ABBYY Cup'а.</p><p>Магический квадрат представляет собой матрицу размера <span class="tex-span"><i>n</i> × <i>n</i></span>. Элементами этой матрицы являются целые числа. Сумма чисел в каждой из строк матрицы равна некоторому числу <span class="tex-span"><i>s</i></span>. Сумма чисел в каждом из столбцов матрицы также равна числу <span class="tex-span"><i>s</i></span>. Кроме этого, сумма элементов на главной диагонали равна <span class="tex-span"><i>s</i></span> и сумма элементов на побочной диагонали равна <span class="tex-span"><i>s</i></span>. Примеры магических квадратов приведены на следующем рисунке:</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/0f8d0ef5e837486a3abad8faab11214ac7fdd6a5.png" /> <span class="tex-font-size-script"> Магические квадраты </span> </center></p><p>Вам дан набор из <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется расположить эти числа в квадратной матрице размера <span class="tex-span"><i>n</i> × <i>n</i></span> таким образом, чтобы они образовывали магический квадрат. Заметим, что каждое число должно встречаться в матрице ровно столько раз, сколько раз оно встречается в исходном наборе.</p><p><span class="tex-font-style-it">Гарантируется, что решение существует!</span></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Следующая строка содержит <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"> - 10<sup class="upper-index">8</sup> ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">8</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 3</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li><li> Гарантируется, что среди <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> не более 9 различных чисел. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Первая строка выходных данных должна содержать целое число <span class="tex-span"><i>s</i></span>. В следующих <span class="tex-span"><i>n</i></span> строках выведите по <span class="tex-span"><i>n</i></span> целых чисел, разделенных пробелами и описывающих полученный магический квадрат. В выведенном магическом квадрате сумма в строках, столбцах и диагоналях должна быть равна <span class="tex-span"><i>s</i></span>. Если решений несколько, разрешается выводить любое.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3<br />1 2 3 4 5 6 7 8 9<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>15<br />2 7 6<br />9 5 1<br />4 3 8<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>3<br />1 0 -1 0 2 -1 -2 0 1<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br />1 0 -1<br />-2 0 2<br />1 0 -1<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>2<br />5 5 5 5<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>10<br />5 5<br />5 5<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">D2. Магические квадраты</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY очень любит различные головоломки. Одной из самых его любимых головоломок являются магические квадраты. Совсем недавно ему пришла в голову идея по автоматизации решения данной головоломки. Бобер решил обратиться с этой задачей к участникам ABBYY Cup'а.</p><p>Магический квадрат представляет собой матрицу размера <span class="tex-span"><i>n</i> × <i>n</i></span>. Элементами этой матрицы являются целые числа. Сумма чисел в каждой из строк матрицы равна некоторому числу <span class="tex-span"><i>s</i></span>. Сумма чисел в каждом из столбцов матрицы также равна числу <span class="tex-span"><i>s</i></span>. Кроме этого, сумма элементов на главной диагонали равна <span class="tex-span"><i>s</i></span> и сумма элементов на побочной диагонали равна <span class="tex-span"><i>s</i></span>. Примеры магических квадратов приведены на следующем рисунке:</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/0f8d0ef5e837486a3abad8faab11214ac7fdd6a5.png" /> <span class="tex-font-size-script"> Магические квадраты </span> </center></p><p>Вам дан набор из <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется расположить эти числа в квадратной матрице размера <span class="tex-span"><i>n</i> × <i>n</i></span> таким образом, чтобы они образовывали магический квадрат. Заметим, что каждое число должно встречаться в матрице ровно столько раз, сколько раз оно встречается в исходном наборе.</p><p><span class="tex-font-style-it">Гарантируется, что решение существует!</span></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Следующая строка содержит <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"> - 10<sup class="upper-index">8</sup> ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">8</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 3</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li><li> Гарантируется, что среди <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> не более 9 различных чисел. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Первая строка выходных данных должна содержать целое число <span class="tex-span"><i>s</i></span>. В следующих <span class="tex-span"><i>n</i></span> строках выведите по <span class="tex-span"><i>n</i></span> целых чисел, разделенных пробелами и описывающих полученный магический квадрат. В выведенном магическом квадрате сумма в строках, столбцах и диагоналях должна быть равна <span class="tex-span"><i>s</i></span>. Если решений несколько, разрешается выводить любое.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3<br />1 2 3 4 5 6 7 8 9<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>15<br />2 7 6<br />9 5 1<br />4 3 8<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>3<br />1 0 -1 0 2 -1 -2 0 1<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br />1 0 -1<br />-2 0 2<br />1 0 -1<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>2<br />5 5 5 5<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>10<br />5 5<br />5 5<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">D3. Магические квадраты</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY очень любит различные головоломки. Одной из самых его любимых головоломок являются магические квадраты. Совсем недавно ему пришла в голову идея по автоматизации решения данной головоломки. Бобер решил обратиться с этой задачей к участникам ABBYY Cup'а.</p><p>Магический квадрат представляет собой матрицу размера <span class="tex-span"><i>n</i> × <i>n</i></span>. Элементами этой матрицы являются целые числа. Сумма чисел в каждой из строк матрицы равна некоторому числу <span class="tex-span"><i>s</i></span>. Сумма чисел в каждом из столбцов матрицы также равна числу <span class="tex-span"><i>s</i></span>. Кроме этого, сумма элементов на главной диагонали равна <span class="tex-span"><i>s</i></span> и сумма элементов на побочной диагонали равна <span class="tex-span"><i>s</i></span>. Примеры магических квадратов приведены на следующем рисунке:</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/0f8d0ef5e837486a3abad8faab11214ac7fdd6a5.png" /> <span class="tex-font-size-script"> Магические квадраты </span> </center></p><p>Вам дан набор из <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span>. Требуется расположить эти числа в квадратной матрице размера <span class="tex-span"><i>n</i> × <i>n</i></span> таким образом, чтобы они образовывали магический квадрат. Заметим, что каждое число должно встречаться в матрице ровно столько раз, сколько раз оно встречается в исходном наборе.</p><p><span class="tex-font-style-it">Гарантируется, что решение существует!</span></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span>. Следующая строка содержит <span class="tex-span"><i>n</i><sup class="upper-index">2</sup></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span"> - 10<sup class="upper-index">8</sup> ≤ <i>a</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">8</sup></span>), разделенных единичными пробелами.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 3</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li><li> Гарантируется, что среди <span class="tex-span"><i>a</i><sub class="lower-index"><i>i</i></sub></span> не более 9 различных чисел. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 4</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Первая строка выходных данных должна содержать целое число <span class="tex-span"><i>s</i></span>. В следующих <span class="tex-span"><i>n</i></span> строках выведите по <span class="tex-span"><i>n</i></span> целых чисел, разделенных пробелами и описывающих полученный магический квадрат. В выведенном магическом квадрате сумма в строках, столбцах и диагоналях должна быть равна <span class="tex-span"><i>s</i></span>. Если решений несколько, разрешается выводить любое.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3<br />1 2 3 4 5 6 7 8 9<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>15<br />2 7 6<br />9 5 1<br />4 3 8<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>3<br />1 0 -1 0 2 -1 -2 0 1<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br />1 0 -1<br />-2 0 2<br />1 0 -1<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>2<br />5 5 5 5<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>10<br />5 5<br />5 5<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">E1. Задача от Бобра - 2</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>5 секунд</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Уже начинает становиться традицией предлагать участникам ABBYY Cup'а задачу, придуманную Умным Бобром. Он предложил следующую задачу.</p><p>Дано монохромное изображение, то есть изображение, состоящее из двух цветов (черного и белого). Изображение представляется в растровом виде, то есть в виде матрицы цветов пикселей, размеры которой совпадают с размерами изображения.</p><p>Белый цвет на заданном изображении соответствует фону. Также на изображении присутствуют геометрические фигуры. Они имеют черный цвет. Известно, что изображение может содержать только два типа фигур: квадраты и круги. Вам требуется посчитать число кругов и число квадратов, которые содержатся на заданном изображении.</p><p>Квадраты на изображении могут быть повернуты произвольным образом. Кроме этого, в изображении возможен шум, устроенный следующим образом: каждый пиксель исходного изображения может с вероятностью <span class="tex-span">20</span>% поменять свой цвет на противоположный.</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/6c180ba14c7bab9f719df8dbb33d5e3fd388ce10.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и стороны квадратов параллельны осям координат (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/c71716c07f5c39066b33a0cb4cf4dec9bb752fa6.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и квадраты повёрнуты произвольным образом (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/d93429c102d497ba8e2d57b8de69f87518d6f74e.png" /> <span class="tex-font-size-script"> Пример изображения, в котором есть шум и квадраты повёрнуты произвольным образом (один круг и три квадрата). </span> </center></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span> (<span class="tex-span">1000 ≤ <i>n</i> ≤ 2000</span>), являющееся длиной и шириной исходного изображения. </p><p>Следующие <span class="tex-span"><i>n</i></span> строк описывают матрицу цветов пикселей изображения. В <span class="tex-span"><i>i</i></span>-ой строке содержится ровно <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>ij</i></sub> ≤ 1</span>), разделенных пробелами. Значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 0</span> соответствует белому пикселю, а <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 1</span> — чёрному. </p><p>Гарантируется, что длины сторон квадратов и диаметры кругов на изображении не менее 15 пикселей, а расстояние между любыми двумя фигурами не менее 10 пикселей. Также гарантируется, что человек всегда может легко посчитать количество соответствующих фигур на исходном изображении. Общее число фигур на изображении не превышает 50.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> В этих тестах нет шума и стороны квадратов параллельны осям координат. </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> В этих тестах нет шума, однако квадраты повёрнуты произвольным образом. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> В этих тестах есть шум и квадраты повёрнуты произвольным образом. </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно два целых числа, разделенных единичным пробелом — число кругов и число квадратов в заданном изображении, соответственно.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"></div></div><div class="note"><div class="section-title">Примечание</div><p>Для каждого уровня сложности вам предлагается пример исходных данных. Скачать примеры можно на <span class="tex-font-style-tt">http://codeforces.ru/static/materials/contests/178/e-samples.zip</span>. </p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">E2. Задача от Бобра - 2</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>5 секунд</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Уже начинает становиться традицией предлагать участникам ABBYY Cup'а задачу, придуманную Умным Бобром. Он предложил следующую задачу.</p><p>Дано монохромное изображение, то есть изображение, состоящее из двух цветов (черного и белого). Изображение представляется в растровом виде, то есть в виде матрицы цветов пикселей, размеры которой совпадают с размерами изображения.</p><p>Белый цвет на заданном изображении соответствует фону. Также на изображении присутствуют геометрические фигуры. Они имеют черный цвет. Известно, что изображение может содержать только два типа фигур: квадраты и круги. Вам требуется посчитать число кругов и число квадратов, которые содержатся на заданном изображении.</p><p>Квадраты на изображении могут быть повернуты произвольным образом. Кроме этого, в изображении возможен шум, устроенный следующим образом: каждый пиксель исходного изображения может с вероятностью <span class="tex-span">20</span>% поменять свой цвет на противоположный.</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/6c180ba14c7bab9f719df8dbb33d5e3fd388ce10.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и стороны квадратов параллельны осям координат (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/c71716c07f5c39066b33a0cb4cf4dec9bb752fa6.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и квадраты повёрнуты произвольным образом (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/d93429c102d497ba8e2d57b8de69f87518d6f74e.png" /> <span class="tex-font-size-script"> Пример изображения, в котором есть шум и квадраты повёрнуты произвольным образом (один круг и три квадрата). </span> </center></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span> (<span class="tex-span">1000 ≤ <i>n</i> ≤ 2000</span>), являющееся длиной и шириной исходного изображения. </p><p>Следующие <span class="tex-span"><i>n</i></span> строк описывают матрицу цветов пикселей изображения. В <span class="tex-span"><i>i</i></span>-ой строке содержится ровно <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>ij</i></sub> ≤ 1</span>), разделенных пробелами. Значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 0</span> соответствует белому пикселю, а <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 1</span> — чёрному. </p><p>Гарантируется, что длины сторон квадратов и диаметры кругов на изображении не менее 15 пикселей, а расстояние между любыми двумя фигурами не менее 10 пикселей. Также гарантируется, что человек всегда может легко посчитать количество соответствующих фигур на исходном изображении. Общее число фигур на изображении не превышает 50.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> В этих тестах нет шума и стороны квадратов параллельны осям координат. </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> В этих тестах нет шума, однако квадраты повёрнуты произвольным образом. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> В этих тестах есть шум и квадраты повёрнуты произвольным образом. </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно два целых числа, разделенных единичным пробелом — число кругов и число квадратов в заданном изображении, соответственно.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"></div></div><div class="note"><div class="section-title">Примечание</div><p>Для каждого уровня сложности вам предлагается пример исходных данных. Скачать примеры можно на <span class="tex-font-style-tt">http://codeforces.ru/static/materials/contests/178/e-samples.zip</span>. </p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">E3. Задача от Бобра - 2</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>5 секунд</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Уже начинает становиться традицией предлагать участникам ABBYY Cup'а задачу, придуманную Умным Бобром. Он предложил следующую задачу.</p><p>Дано монохромное изображение, то есть изображение, состоящее из двух цветов (черного и белого). Изображение представляется в растровом виде, то есть в виде матрицы цветов пикселей, размеры которой совпадают с размерами изображения.</p><p>Белый цвет на заданном изображении соответствует фону. Также на изображении присутствуют геометрические фигуры. Они имеют черный цвет. Известно, что изображение может содержать только два типа фигур: квадраты и круги. Вам требуется посчитать число кругов и число квадратов, которые содержатся на заданном изображении.</p><p>Квадраты на изображении могут быть повернуты произвольным образом. Кроме этого, в изображении возможен шум, устроенный следующим образом: каждый пиксель исходного изображения может с вероятностью <span class="tex-span">20</span>% поменять свой цвет на противоположный.</p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/6c180ba14c7bab9f719df8dbb33d5e3fd388ce10.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и стороны квадратов параллельны осям координат (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/c71716c07f5c39066b33a0cb4cf4dec9bb752fa6.png" /> <span class="tex-font-size-script"> Пример изображения, в котором нет шума и квадраты повёрнуты произвольным образом (два круга и три квадрата). </span> </center></p><p><center> <img class="tex-graphics" src="http://codeforces.ru/renderer/d93429c102d497ba8e2d57b8de69f87518d6f74e.png" /> <span class="tex-font-size-script"> Пример изображения, в котором есть шум и квадраты повёрнуты произвольным образом (один круг и три квадрата). </span> </center></p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит единственное целое число <span class="tex-span"><i>n</i></span> (<span class="tex-span">1000 ≤ <i>n</i> ≤ 2000</span>), являющееся длиной и шириной исходного изображения. </p><p>Следующие <span class="tex-span"><i>n</i></span> строк описывают матрицу цветов пикселей изображения. В <span class="tex-span"><i>i</i></span>-ой строке содержится ровно <span class="tex-span"><i>n</i></span> целых чисел <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub></span> (<span class="tex-span">0 ≤ <i>a</i><sub class="lower-index"><i>ij</i></sub> ≤ 1</span>), разделенных пробелами. Значение <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 0</span> соответствует белому пикселю, а <span class="tex-span"><i>a</i><sub class="lower-index"><i>ij</i></sub> = 1</span> — чёрному. </p><p>Гарантируется, что длины сторон квадратов и диаметры кругов на изображении не менее 15 пикселей, а расстояние между любыми двумя фигурами не менее 10 пикселей. Также гарантируется, что человек всегда может легко посчитать количество соответствующих фигур на исходном изображении. Общее число фигур на изображении не превышает 50.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> В этих тестах нет шума и стороны квадратов параллельны осям координат. </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> В этих тестах нет шума, однако квадраты повёрнуты произвольным образом. </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> В этих тестах есть шум и квадраты повёрнуты произвольным образом. </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите ровно два целых числа, разделенных единичным пробелом — число кругов и число квадратов в заданном изображении, соответственно.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"></div></div><div class="note"><div class="section-title">Примечание</div><p>Для каждого уровня сложности вам предлагается пример исходных данных. Скачать примеры можно на <span class="tex-font-style-tt">http://codeforces.ru/static/materials/contests/178/e-samples.zip</span>. </p></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">F1. Репрезентативная выборка</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY уже давно сотрудничает с НИИ «Цитологии и Генетики». Недавно работники этого НИИ предложили Бобру новую задачу. Суть задачи заключалась в следующем.</p><p>Есть набор из <span class="tex-span"><i>n</i></span> белков (не обязательно различных). Каждый белок представляет собой строку, состоящую из маленьких букв латинского алфавита. Задача, которую поставили перед Умным Бобром ученые, заключается в выборе поднабора мощности <span class="tex-span"><i>k</i></span> из исходного набора белков, причём репрезентативность выбранного поднабора белков должна быть максимальной.</p><p>Умный Бобер из ABBYY провел небольшое исследование и пришел к выводу, что репрезентативность набора белков можно оценить одним числом, которое достаточно просто вычисляется. Пусть у нас есть набор <span class="tex-span">{<i>a</i><sub class="lower-index">1</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub>}</span> из <span class="tex-span"><i>k</i></span> строк, описывающих белки. Репрезентативностью этого набора называется следующая величина:</p><p><center class="tex-equation"><img align="middle" class="tex-formula" src="http://codeforces.ru/renderer/3e36ab17924254d46f39e766fb8791e040113a32.png" /></center> </p><p>где <span class="tex-span"><i>f</i>(<i>x</i>, <i>y</i>)</span> — длина наибольшего общего префикса строк <span class="tex-span"><i>x</i></span> и <span class="tex-span"><i>y</i></span>; например, <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>»<span class="tex-span">) = 2</span>, а <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">ab</span>», «<span class="tex-font-style-tt">bcd</span>»<span class="tex-span">) = 0</span>. </p><p>Таким образом, репрезентативность набора белков <span class="tex-span">{</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>», «<span class="tex-font-style-tt">abe</span>»<span class="tex-span">}</span> равна <span class="tex-span">6</span>, а набора <span class="tex-span">{</span>«<span class="tex-font-style-tt">aaa</span>», «<span class="tex-font-style-tt">ba</span>», «<span class="tex-font-style-tt">ba</span>»<span class="tex-span">}</span> — <span class="tex-span">2</span>.</p><p>После этого открытия Умный Бобер из ABBYY обратился к участникам Cup'а с просьбой написать программу, выбирающую из заданного набора белков поднабор мощности <span class="tex-span"><i>k</i></span>, который имеет наибольшее возможное значение репрезентативности. Помогите ему с решением этой задачи!</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>k</i></span> (<span class="tex-span">1 ≤ <i>k</i> ≤ <i>n</i></span>), разделенных единичным пробелом. Следующие <span class="tex-span"><i>n</i></span> строк содержат описания белков по одному в строке. Каждый белок представляет собой непустую строку длиной не более <span class="tex-span">500</span> символов, состоящую только из строчных латинских букв (<span class="tex-font-style-tt">a</span><span class="tex-span">...</span><span class="tex-font-style-tt">z</span>). Строки могут совпадать.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 20</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 100</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — наибольшее возможное значение репрезентативности поднабора мощности <span class="tex-span"><i>k</i></span> заданного набора белков.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3 2<br />aba<br />bzd<br />abq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />eee<br />rrr<br />ttt<br />qqq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />aaa<br />abba<br />abbc<br />abbd<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>9<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 4em;page-break-after: always;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">F2. Репрезентативная выборка</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY уже давно сотрудничает с НИИ «Цитологии и Генетики». Недавно работники этого НИИ предложили Бобру новую задачу. Суть задачи заключалась в следующем.</p><p>Есть набор из <span class="tex-span"><i>n</i></span> белков (не обязательно различных). Каждый белок представляет собой строку, состоящую из маленьких букв латинского алфавита. Задача, которую поставили перед Умным Бобром ученые, заключается в выборе поднабора мощности <span class="tex-span"><i>k</i></span> из исходного набора белков, причём репрезентативность выбранного поднабора белков должна быть максимальной.</p><p>Умный Бобер из ABBYY провел небольшое исследование и пришел к выводу, что репрезентативность набора белков можно оценить одним числом, которое достаточно просто вычисляется. Пусть у нас есть набор <span class="tex-span">{<i>a</i><sub class="lower-index">1</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub>}</span> из <span class="tex-span"><i>k</i></span> строк, описывающих белки. Репрезентативностью этого набора называется следующая величина:</p><p><center class="tex-equation"><img align="middle" class="tex-formula" src="http://codeforces.ru/renderer/3e36ab17924254d46f39e766fb8791e040113a32.png" /></center> </p><p>где <span class="tex-span"><i>f</i>(<i>x</i>, <i>y</i>)</span> — длина наибольшего общего префикса строк <span class="tex-span"><i>x</i></span> и <span class="tex-span"><i>y</i></span>; например, <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>»<span class="tex-span">) = 2</span>, а <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">ab</span>», «<span class="tex-font-style-tt">bcd</span>»<span class="tex-span">) = 0</span>. </p><p>Таким образом, репрезентативность набора белков <span class="tex-span">{</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>», «<span class="tex-font-style-tt">abe</span>»<span class="tex-span">}</span> равна <span class="tex-span">6</span>, а набора <span class="tex-span">{</span>«<span class="tex-font-style-tt">aaa</span>», «<span class="tex-font-style-tt">ba</span>», «<span class="tex-font-style-tt">ba</span>»<span class="tex-span">}</span> — <span class="tex-span">2</span>.</p><p>После этого открытия Умный Бобер из ABBYY обратился к участникам Cup'а с просьбой написать программу, выбирающую из заданного набора белков поднабор мощности <span class="tex-span"><i>k</i></span>, который имеет наибольшее возможное значение репрезентативности. Помогите ему с решением этой задачи!</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>k</i></span> (<span class="tex-span">1 ≤ <i>k</i> ≤ <i>n</i></span>), разделенных единичным пробелом. Следующие <span class="tex-span"><i>n</i></span> строк содержат описания белков по одному в строке. Каждый белок представляет собой непустую строку длиной не более <span class="tex-span">500</span> символов, состоящую только из строчных латинских букв (<span class="tex-font-style-tt">a</span><span class="tex-span">...</span><span class="tex-font-style-tt">z</span>). Строки могут совпадать.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 20</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 100</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — наибольшее возможное значение репрезентативности поднабора мощности <span class="tex-span"><i>k</i></span> заданного набора белков.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3 2<br />aba<br />bzd<br />abq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />eee<br />rrr<br />ttt<br />qqq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />aaa<br />abba<br />abbc<br />abbd<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>9<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>
        <div
                    style="margin-bottom: 2em;"
        >

<div class="ttypography"><div class="problem-statement"><div class="header"><div class="title">F3. Репрезентативная выборка</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Умный Бобер из ABBYY уже давно сотрудничает с НИИ «Цитологии и Генетики». Недавно работники этого НИИ предложили Бобру новую задачу. Суть задачи заключалась в следующем.</p><p>Есть набор из <span class="tex-span"><i>n</i></span> белков (не обязательно различных). Каждый белок представляет собой строку, состоящую из маленьких букв латинского алфавита. Задача, которую поставили перед Умным Бобром ученые, заключается в выборе поднабора мощности <span class="tex-span"><i>k</i></span> из исходного набора белков, причём репрезентативность выбранного поднабора белков должна быть максимальной.</p><p>Умный Бобер из ABBYY провел небольшое исследование и пришел к выводу, что репрезентативность набора белков можно оценить одним числом, которое достаточно просто вычисляется. Пусть у нас есть набор <span class="tex-span">{<i>a</i><sub class="lower-index">1</sub>, ..., <i>a</i><sub class="lower-index"><i>k</i></sub>}</span> из <span class="tex-span"><i>k</i></span> строк, описывающих белки. Репрезентативностью этого набора называется следующая величина:</p><p><center class="tex-equation"><img align="middle" class="tex-formula" src="http://codeforces.ru/renderer/3e36ab17924254d46f39e766fb8791e040113a32.png" /></center> </p><p>где <span class="tex-span"><i>f</i>(<i>x</i>, <i>y</i>)</span> — длина наибольшего общего префикса строк <span class="tex-span"><i>x</i></span> и <span class="tex-span"><i>y</i></span>; например, <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>»<span class="tex-span">) = 2</span>, а <span class="tex-span"><i>f</i>(</span>«<span class="tex-font-style-tt">ab</span>», «<span class="tex-font-style-tt">bcd</span>»<span class="tex-span">) = 0</span>. </p><p>Таким образом, репрезентативность набора белков <span class="tex-span">{</span>«<span class="tex-font-style-tt">abc</span>», «<span class="tex-font-style-tt">abd</span>», «<span class="tex-font-style-tt">abe</span>»<span class="tex-span">}</span> равна <span class="tex-span">6</span>, а набора <span class="tex-span">{</span>«<span class="tex-font-style-tt">aaa</span>», «<span class="tex-font-style-tt">ba</span>», «<span class="tex-font-style-tt">ba</span>»<span class="tex-span">}</span> — <span class="tex-span">2</span>.</p><p>После этого открытия Умный Бобер из ABBYY обратился к участникам Cup'а с просьбой написать программу, выбирающую из заданного набора белков поднабор мощности <span class="tex-span"><i>k</i></span>, который имеет наибольшее возможное значение репрезентативности. Помогите ему с решением этой задачи!</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка входных данных содержит два целых числа <span class="tex-span"><i>n</i></span> и <span class="tex-span"><i>k</i></span> (<span class="tex-span">1 ≤ <i>k</i> ≤ <i>n</i></span>), разделенных единичным пробелом. Следующие <span class="tex-span"><i>n</i></span> строк содержат описания белков по одному в строке. Каждый белок представляет собой непустую строку длиной не более <span class="tex-span">500</span> символов, состоящую только из строчных латинских букв (<span class="tex-font-style-tt">a</span><span class="tex-span">...</span><span class="tex-font-style-tt">z</span>). Строки могут совпадать.</p><p>Ограничения на входные данные для получения 20 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 20</span> </li></ul></p><p>Ограничения на входные данные для получения 50 баллов: <ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 100</span> </li></ul></p><p>Ограничения на входные данные для получения 100 баллов:</p><p><ul> <li> <span class="tex-span">1 ≤ <i>n</i> ≤ 2000</span> </li></ul></p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите одно целое число — наибольшее возможное значение репрезентативности поднабора мощности <span class="tex-span"><i>k</i></span> заданного набора белков.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>3 2<br />aba<br />bzd<br />abq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>2<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />eee<br />rrr<br />ttt<br />qqq<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>0<br /></pre></div><div class="input"><div class="title">Входные данные</div><pre>4 3<br />aaa<br />abba<br />abbc<br />abbd<br /></pre></div><div class="output"><div class="title">Выходные данные</div><pre>9<br /></pre></div></div></div></div></div>

<script type="text/javascript">
    $(document).ready(function() {
        function endsWith(string, suffix) {
            return string.indexOf(suffix, string.length - suffix.length) !== -1;
        }

        var inputFileDiv = $("div.input-file");
        var inputFile = inputFileDiv.text();
        var outputFileDiv = $("div.output-file");
        var outputFile = outputFileDiv.text();

        if (!endsWith(inputFile, "стандартный ввод")) {
            inputFileDiv.attr("style", "font-weight: bold");
        }

        if (!endsWith(outputFile, "стандартный вывод")) {
            outputFileDiv.attr("style", "font-weight: bold");
        }
    });
</script>
        </div>

    <br style="clear:both;"/>

    <div id="footer">
        <div><a href="http://codeforces.ru/">Codeforces</a> (c) Copyright 2010-2013 Михаил Мирзаянов</div>
        <div>Соревнования по программированию 2.0</div>

    </div>
</div>
</div>
</body>
</html>                                       
