<div class="problem-statement"><div class="header"><div class="title">E. Дерево и массив</div><div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div><div class="memory-limit"><div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div><div class="input-file"><div class="property-title">ввод</div>стандартный ввод</div><div class="output-file"><div class="property-title">вывод</div>стандартный вывод</div></div><div><p>Пользователь ainta любит деревья. В этот раз он собирается построить неориентированное дерево, состоящее из <span class="tex-span"><i>n</i></span> вершин, пронумерованных целыми числами от <span class="tex-span">1</span> до <span class="tex-span"><i>n</i></span>. Дерево — взвешенное, то есть каждое ребро дерева имеет некоторый целочисленный вес.</p><p>Также у юноши есть массив <span class="tex-span"><i>t</i></span>: <span class="tex-span"><i>t</i>[1], <i>t</i>[2], ..., <i>t</i>[<i>n</i>]</span>. Сперва все элементы массива инициализируются значением <span class="tex-span">0</span>. Затем для каждого ребра, соединяющего вершины <span class="tex-span"><i>u</i></span> и <span class="tex-span"><i>v</i></span> (<span class="tex-span"><i>u</i> &lt; <i>v</i></span>) дерева с весом <span class="tex-span"><i>c</i></span>, ainta добавляет значение <span class="tex-span"><i>c</i></span> к элементам <span class="tex-span"><i>t</i>[<i>u</i>], <i>t</i>[<i>u</i> + 1], ..., <i>t</i>[<i>v</i> - 1], <i>t</i>[<i>v</i>]</span> массива <span class="tex-span"><i>t</i></span>.</p><p>Обозначим суммарный вес ребер на кратчайшем пути от вершины <span class="tex-span"><i>u</i></span> до <span class="tex-span"><i>v</i></span> записью <span class="tex-span"><i>d</i>(<i>u</i>, <i>v</i>)</span>. Пользователь ainta называет пару целых чисел <span class="tex-span"><i>x</i>, <i>y</i></span> (<span class="tex-span">1 ≤ <i>x</i> &lt; <i>y</i> ≤ <i>n</i></span>) <span class="tex-font-style-it">хорошей</span> тогда и только тогда, когда <span class="tex-span"><i>d</i>(<i>x</i>, <i>y</i>) = <i>t</i>[<i>x</i>] + <i>t</i>[<i>x</i> + 1] + ... + <i>t</i>[<i>y</i> - 1] + <i>t</i>[<i>y</i>]</span>.</p><p>Пользователь ainta хочет получить не меньше <img align="middle" class="tex-formula" src="http://espresso.codeforces.com/832254ba69494673dbc525f2e9193b28c955acd0.png" /> хороших пар, но у него не получается построить соответствующее дерево. Помогите ainta найти такое дерево.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>Первая строка содержит единственное целое число <span class="tex-span"><i>n</i></span> (<span class="tex-span">5 ≤ <i>n</i> ≤ 10<sup class="upper-index">5</sup></span>).</p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите <span class="tex-span"><i>n</i> - 1</span> строк, содержащих описание ребер: <span class="tex-span"><i>i</i></span>-я строка должна содержать три целых числа через пробел <span class="tex-span"><i>u</i><sub class="lower-index"><i>i</i></sub>, <i>v</i><sub class="lower-index"><i>i</i></sub>, <i>c</i><sub class="lower-index"><i>i</i></sub></span> (<span class="tex-span">1 ≤ <i>u</i><sub class="lower-index"><i>i</i></sub> &lt; <i>v</i><sub class="lower-index"><i>i</i></sub> ≤ <i>n</i>; 1 ≤ <i>c</i><sub class="lower-index"><i>i</i></sub> ≤ 10<sup class="upper-index">5</sup></span>) — две вершины, соединенные ребром дерева, и вес этого ребра.</p><p>Дальше выведите <img align="middle" class="tex-formula" src="http://espresso.codeforces.com/ff3debcd979cb1dbc17aecf1e75e31f997a019f8.png" /> строк, содержащих хорошие пары. В <span class="tex-span"><i>k</i></span>-й строке должны быть записаны два целых числа через пробел, <span class="tex-span"><i>x</i><sub class="lower-index"><i>k</i></sub></span> и <span class="tex-span"><i>y</i><sub class="lower-index"><i>k</i></sub></span> (<span class="tex-span">1 ≤ <i>x</i><sub class="lower-index"><i>k</i></sub> &lt; <i>y</i><sub class="lower-index"><i>k</i></sub> ≤ <i>n</i></span>). Конечно же, <span class="tex-span"><i>x</i><sub class="lower-index"><i>k</i></sub>, <i>y</i><sub class="lower-index"><i>k</i></sub></span> должны образовывать хорошую пару. Все пары должны быть различны — иными словами, для всех <span class="tex-span"><i>j</i>, <i>k</i></span> <img align="middle" class="tex-formula" src="http://espresso.codeforces.com/c6a49d75d528a56e2ceb8fbc8357292970294cff.png" />, должно выполняться условие <span class="tex-span"><i>x</i><sub class="lower-index"><i>j</i></sub> ≠ <i>x</i><sub class="lower-index"><i>k</i></sub></span> или <span class="tex-span"><i>y</i><sub class="lower-index"><i>j</i></sub> ≠ <i>y</i><sub class="lower-index"><i>k</i></sub></span>.</p><p>Если существует несколько правильных ответов, разрешается вывести любой из них.</p></div><div class="sample-tests"><div class="section-title">Примеры тестов</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>7</pre></div><div class="output"><div class="title">Выходные данные</div><pre>1 4 1<br />1 2 2<br />2 3 5<br />3 5 3<br />2 6 2<br />6 7 3<br />4 5<br />5 6<br />5 7</pre></div></div></div><div class="note"><div class="section-title">Примечание</div><p><span class="tex-span">⌊<i>x</i>⌋</span> — это наибольшее целое число, не превышающее <span class="tex-span"><i>x</i></span>.</p><p>Вы можете найти определение дерева по следующей ссылке: <span class="tex-font-style-tt">http://ru.wikipedia.org/wiki/Дерево_(теория_графов)</span></p><p>Также вы можете найти определение кратчайшего пути по следующей ссылке: <span class="tex-font-style-tt">http://ru.wikipedia.org/wiki/Задача_о_кратчайшем_пути</span></p><p>Дерево и массив <span class="tex-span"><i>t</i></span> в тестовом примере выглядят следующим образом:</p><center> <img class="tex-graphics" src="http://espresso.codeforces.com/518774466402576f6a600ec2fc22bde02bda4b28.png" /> </center></div></div></div>
</div>


